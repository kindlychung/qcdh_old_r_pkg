{
    "contents" : "collapseGen = function(...) UseMethod('collapseGen')\n\ncollapseGen.default = function(hapm1, hapm2=NULL, win, collmethod=2) {\n\n    stopifnot(all(dim(hapm1) == dim(hapm2)))\n\n    if(inherits(win, 'winIdx')) {\n        startsnp = win$startsnp\n        winidx = win$winidx\n    } else {\n        nsnps = nrow(hapm1)\n        win = as.integer(win)\n        stopifnot(length(win) == 1 & win > 0 & win <= nsnps)\n        startsnp = win\n        if(win < nsnps) winidx = (win+1):nsnps\n        else winidx = integer(0)\n    }\n    winwidth = length(winidx)\n\n    if(is.null(hapm2)) {\n        cat('Only one matrix given, assuming unphased data.\\n')\n        snpfix = snp_no_collapse = hapm1[startsnp, , drop=FALSE]\n\n        if(winwidth > 0) {\n            snpvar = hapm1[winidx, , drop=FALSE]\n            snpfix = snpfix[rep(1, winwidth), ]\n\n            cgen = collapseGen.geno(snpfix, snpvar, collmethod, snp_no_collapse)\n\n            re = list(snpidx=c(startsnp, winidx),\n                      cgen=cgen)\n        } else {\n            re = list(snpidx = startsnp,\n                      cgen = t(snp_no_collapse))\n        }\n\n    } else {\n        cat('Two matrices given, assuming phased data.\\n')\n\n        snpfix1 = hapm1[startsnp, , drop=FALSE]\n        snpfix2 = hapm2[startsnp, , drop=FALSE]\n        snp_no_collapse = snpfix1 + snpfix2\n\n        if(winwidth > 0) {\n            snpvar1 = hapm1[winidx, , drop=FALSE]\n            snpvar2 = hapm2[winidx, , drop=FALSE]\n            snpfix1 = snpfix1[rep(1, winwidth), ]\n            snpfix2 = snpfix2[rep(1, winwidth), ]\n\n            cgen = collapseGen.haplo(snpfix1, snpfix2, snpvar1, snpvar2, collmethod, snp_no_collapse)\n\n            re = list(snpidx=c(startsnp, winidx),\n                      cgen=cgen)\n        } else {\n            re = list(snpidx = startsnp,\n                      cgen = t(snp_no_collapse))\n        }\n    }\n\n    class(re) = c('collapsegen', class(re))\n    re\n}\n\n\ncollapseGen.geno = function(snpfix, snpvar, collmethod, snp_no_collapse) {\n    if(is.null(dim(snpfix))) snpfix = matrix(snpfix, nrow=1)\n    if(is.null(dim(snpvar))) snpvar = matrix(snpvar, nrow=1)\n\n    gsum = round(snpfix + snpvar)\n\n    cgen = (gsum > 1) + 0\n    idx = which(gsum > 2)\n\n    if(collmethod == 2) {\n\n    } else if(collmethod == 1) {\n        cgen[idx] = 0\n    } else if(collmethod == 3) {\n        cgen[idx] = NA\n    } else {\n        stop('Unknown collmethod option!')\n    }\n\n    if(!missing(snp_no_collapse)) \n        cgen = rbind(snp_no_collapse, cgen)\n    dimnames(cgen) = NULL\n    cgen = t(cgen)\n    cgen\n}\n\n\ncollapseGen.haplo = function(snpfix1, snpfix2, snpvar1, snpvar2, collmethod, snp_no_collapse) {\n    if(is.null(dim(snpfix1))) snpfix1 = matrix(snpfix1, nrow=1)\n    if(is.null(dim(snpfix2))) snpfix2 = matrix(snpfix2, nrow=1)\n    if(is.null(dim(snpvar1))) snpvar1 = matrix(snpvar1, nrow=1)\n    if(is.null(dim(snpvar2))) snpvar2 = matrix(snpvar2, nrow=1)\n\n    gsum = round((snpfix1 + snpvar1) * (snpfix2 + snpvar2))\n    cgen = (gsum > 0) + 0\n    idx = which(gsum > 1)\n\n    if(collmethod == 2) {\n    } else if(collmethod == 1) {\n        cgen[idx] = 0\n    } else if(collmethod == 3) {\n        cgen[idx] = NA\n    } else {\n        stop('Unknown collmethod option!')\n    }\n\n    if(!missing(snp_no_collapse)) \n        cgen = rbind(snp_no_collapse, cgen)\n    dimnames(cgen) = NULL\n\n    cgen = t(cgen)\n    cgen\n}\n",
    "created" : 1393330756793.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "827043660",
    "id" : "C28DAD9D",
    "lastKnownWriteTime" : 1393348180,
    "path" : "~/rpkgs/qcdh/R/collapseGen.r",
    "project_path" : "R/collapseGen.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}